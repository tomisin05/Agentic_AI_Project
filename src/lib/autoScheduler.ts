// Auto-Scheduler: Generates study schedules from goal deadlines
// Intelligently distributes study time based on goal priority, deadline, and user patterns

import { StudyGoal, GoalManager, GoalProgress, GoalTask } from './goalSystem';

export interface ScheduledSession {
  id: string;
  goalId: string;
  taskId?: string;
  title: string;
  date: Date;
  startTime: string; // HH:MM format
  duration: number; // minutes
  sessionType: 'deep-work' | 'review' | 'flashcards' | 'light-study';
  priority: 'low' | 'medium' | 'high' | 'critical';
  autoGenerated: boolean;
  completed?: boolean;
}

export interface WeeklySchedule {
  weekStart: Date;
  weekEnd: Date;
  sessions: ScheduledSession[];
  totalMinutes: number;
  goalsIncluded: string[];
}

export interface UserStudyPattern {
  preferredTimes: Array<{ day: number; hour: number }>; // day: 0-6 (Sun-Sat), hour: 0-23
  averageSessionDuration: number;
  productiveHours: number[]; // hours when user is most focused
  avoidDays: number[]; // days to skip (e.g., weekends)
}

export class AutoScheduler {
  private static readonly STORAGE_KEY = 'pomodoro-auto-schedule';
  private static readonly PATTERN_KEY = 'pomodoro-study-pattern';

  // Generate a weekly study schedule from active goals
  static generateWeeklySchedule(
    startDate: Date = new Date(),
    userPattern?: UserStudyPattern
  ): WeeklySchedule {
    const pattern = userPattern || this.getDefaultPattern();
    const activeGoals = GoalManager.getActiveGoals();
    
    if (activeGoals.length === 0) {
      return {
        weekStart: startDate,
        weekEnd: new Date(startDate.getTime() + 7 * 24 * 60 * 60 * 1000),
        sessions: [],
        totalMinutes: 0,
        goalsIncluded: []
      };
    }

    const sessions: ScheduledSession[] = [];
    const weekEnd = new Date(startDate.getTime() + 7 * 24 * 60 * 60 * 1000);

    // Calculate time allocation for each goal
    const allocations = this.calculateTimeAllocations(activeGoals, pattern);

    // Distribute sessions across the week
    for (const allocation of allocations) {
      const goalSessions = this.generateSessionsForGoal(
        allocation.goal,
        allocation.minutesPerWeek,
        startDate,
        pattern
      );
      sessions.push(...goalSessions);
    }

    // Sort sessions by date and time
    sessions.sort((a, b) => {
      const dateCompare = a.date.getTime() - b.date.getTime();
      if (dateCompare !== 0) return dateCompare;
      return a.startTime.localeCompare(b.startTime);
    });

    return {
      weekStart: startDate,
      weekEnd,
      sessions,
      totalMinutes: sessions.reduce((sum, s) => sum + s.duration, 0),
      goalsIncluded: [...new Set(sessions.map(s => s.goalId))]
    };
  }

  private static calculateTimeAllocations(
    goals: StudyGoal[],
    pattern: UserStudyPattern
  ): Array<{ goal: StudyGoal; minutesPerWeek: number; priority: number }> {
    const allocations: Array<{ goal: StudyGoal; minutesPerWeek: number; priority: number }> = [];
    
    for (const goal of goals) {
      const progress = GoalManager.calculateProgress(goal.id);
      
      // Calculate base minutes needed per week
      let weeklyMinutes = 0;
      
      if (goal.weeklyCommitment) {
        // User explicitly set weekly commitment (in sessions)
        weeklyMinutes = goal.weeklyCommitment * pattern.averageSessionDuration;
      } else if (goal.dailyCommitment) {
        // Convert daily to weekly
        weeklyMinutes = goal.dailyCommitment * 7;
      } else if (progress.recommendedDailyMinutes > 0) {
        // Use calculated recommendation
        weeklyMinutes = progress.recommendedDailyMinutes * 7;
      } else {
        // Default: 3 sessions per week
        weeklyMinutes = 3 * pattern.averageSessionDuration;
      }

      // Adjust based on urgency
      let priorityScore = 5;
      
      if (progress.daysUntilDeadline !== undefined) {
        if (progress.daysUntilDeadline <= 3) {
          priorityScore = 10;
          weeklyMinutes *= 1.5; // Boost time for urgent goals
        } else if (progress.daysUntilDeadline <= 7) {
          priorityScore = 8;
          weeklyMinutes *= 1.2;
        }
      }

      // Adjust by goal priority
      const priorityBoost = { critical: 3, high: 2, medium: 0, low: -1 };
      priorityScore += priorityBoost[goal.priority];

      // Adjust based on progress (behind = more time)
      if (!progress.onTrack && progress.progressPercentage < 75) {
        weeklyMinutes *= 1.3;
        priorityScore += 2;
      }

      allocations.push({
        goal,
        minutesPerWeek: Math.round(weeklyMinutes),
        priority: priorityScore
      });
    }

    // Sort by priority
    allocations.sort((a, b) => b.priority - a.priority);

    return allocations;
  }

  private static generateSessionsForGoal(
    goal: StudyGoal,
    weeklyMinutes: number,
    startDate: Date,
    pattern: UserStudyPattern
  ): ScheduledSession[] {
    const sessions: ScheduledSession[] = [];
    const progress = GoalManager.calculateProgress(goal.id);
    
    // Determine session type distribution
    const sessionTypes = this.determineSessionTypes(goal, progress);
    
    // Calculate number of sessions
    const sessionCount = Math.max(
      1,
      Math.round(weeklyMinutes / pattern.averageSessionDuration)
    );
    
    // Get incomplete tasks for this goal
    const incompleteTasks = goal.tasks.filter(t => t.status !== 'completed');
    
    // Generate sessions spread across the week
    const availableSlots = this.getAvailableTimeSlots(startDate, pattern);
    
    let minutesRemaining = weeklyMinutes;
    let sessionIndex = 0;
    let taskIndex = 0;

    while (minutesRemaining > 0 && sessionIndex < sessionCount && availableSlots.length > 0) {
      const slot = availableSlots[sessionIndex % availableSlots.length];
      const sessionType = sessionTypes[sessionIndex % sessionTypes.length];
      
      // Determine duration for this session
      const duration = Math.min(
        pattern.averageSessionDuration,
        minutesRemaining,
        sessionType === 'deep-work' ? 50 : 25
      );

      // Link to a task if available
      const task = incompleteTasks[taskIndex % Math.max(1, incompleteTasks.length)];
      
      const session: ScheduledSession = {
        id: crypto.randomUUID(),
        goalId: goal.id,
        taskId: task?.id,
        title: task ? task.title : `Study: ${goal.title}`,
        date: slot.date,
        startTime: slot.time,
        duration,
        sessionType,
        priority: goal.priority,
        autoGenerated: true,
        completed: false
      };

      sessions.push(session);
      
      minutesRemaining -= duration;
      sessionIndex++;
      
      if (task) {
        taskIndex++;
      }
    }

    return sessions;
  }

  private static determineSessionTypes(
    goal: StudyGoal,
    progress: GoalProgress
  ): Array<'deep-work' | 'review' | 'flashcards' | 'light-study'> {
    const types: Array<'deep-work' | 'review' | 'flashcards' | 'light-study'> = [];
    
    // Early stage: more deep work
    if (progress.progressPercentage < 50) {
      types.push('deep-work', 'deep-work', 'light-study');
    }
    // Mid stage: mix of deep work and review
    else if (progress.progressPercentage < 75) {
      types.push('deep-work', 'review', 'flashcards');
    }
    // Final stage: more review and flashcards
    else {
      types.push('review', 'flashcards', 'review');
    }

    // If goal has many flashcards, add more flashcard sessions
    if (goal.flashcardsCreated > 20) {
      types.push('flashcards');
    }

    return types;
  }

  private static getAvailableTimeSlots(
    startDate: Date,
    pattern: UserStudyPattern
  ): Array<{ date: Date; time: string }> {
    const slots: Array<{ date: Date; time: string }> = [];
    
    // Generate slots for 7 days
    for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
      const date = new Date(startDate);
      date.setDate(date.getDate() + dayOffset);
      date.setHours(0, 0, 0, 0);
      
      const dayOfWeek = date.getDay();
      
      // Skip if user wants to avoid this day
      if (pattern.avoidDays.includes(dayOfWeek)) {
        continue;
      }

      // Use productive hours or default times
      const hours = pattern.productiveHours.length > 0 
        ? pattern.productiveHours 
        : [9, 14, 19]; // Morning, afternoon, evening defaults

      for (const hour of hours) {
        slots.push({
          date: new Date(date),
          time: `${hour.toString().padStart(2, '0')}:00`
        });
      }
    }

    return slots;
  }

  private static getDefaultPattern(): UserStudyPattern {
    // Try to load saved pattern
    try {
      const stored = localStorage.getItem(this.PATTERN_KEY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      console.error('Failed to load study pattern:', error);
    }

    // Return sensible defaults
    return {
      preferredTimes: [],
      averageSessionDuration: 25,
      productiveHours: [9, 14, 17, 20], // Morning, early afternoon, late afternoon, evening
      avoidDays: [] // No days avoided by default
    };
  }

  static saveUserPattern(pattern: UserStudyPattern): void {
    try {
      localStorage.setItem(this.PATTERN_KEY, JSON.stringify(pattern));
    } catch (error) {
      console.error('Failed to save study pattern:', error);
    }
  }

  static getUserPattern(): UserStudyPattern {
    return this.getDefaultPattern();
  }

  // Learn from user's actual study sessions
  static learnFromHistory(journalEntries: any[]): UserStudyPattern {
    const pattern = this.getDefaultPattern();
    
    if (journalEntries.length < 5) {
      return pattern; // Not enough data
    }

    // Analyze when user actually studies
    const hourCounts: Record<number, number> = {};
    const dayCounts: Record<number, number> = {};
    let totalDuration = 0;

    for (const entry of journalEntries) {
      const date = new Date(entry.date);
      const hour = date.getHours();
      const day = date.getDay();
      
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
      dayCounts[day] = (dayCounts[day] || 0) + 1;
      totalDuration += 25; // Assume 25 min sessions
    }

    // Find most productive hours (top 4)
    const sortedHours = Object.entries(hourCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 4)
      .map(([hour]) => parseInt(hour));

    pattern.productiveHours = sortedHours;
    pattern.averageSessionDuration = Math.round(totalDuration / journalEntries.length);

    // Find days user rarely studies (avoid them)
    const avgSessionsPerDay = journalEntries.length / 7;
    pattern.avoidDays = Object.entries(dayCounts)
      .filter(([, count]) => count < avgSessionsPerDay * 0.3)
      .map(([day]) => parseInt(day));

    this.saveUserPattern(pattern);
    return pattern;
  }

  // Export schedule to calendar format
  static exportScheduleToICS(schedule: WeeklySchedule): string {
    const events: string[] = [];

    for (const session of schedule.sessions) {
      const goal = GoalManager.getGoals().find(g => g.id === session.goalId);
      const startDateTime = this.parseDateTime(session.date, session.startTime);
      const endDateTime = new Date(startDateTime.getTime() + session.duration * 60 * 1000);

      const formatDate = (date: Date) => {
        return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      };

      events.push(`BEGIN:VEVENT
UID:${session.id}@pomodoro-app.com
DTSTAMP:${formatDate(new Date())}
DTSTART:${formatDate(startDateTime)}
DTEND:${formatDate(endDateTime)}
SUMMARY:${session.title}
DESCRIPTION:Auto-scheduled study session for ${goal?.title}\\nType: ${session.sessionType}\\nDuration: ${session.duration} minutes
PRIORITY:${session.priority === 'critical' ? '1' : session.priority === 'high' ? '3' : '5'}
BEGIN:VALARM
TRIGGER:-PT10M
ACTION:DISPLAY
DESCRIPTION:Study session starts in 10 minutes
END:VALARM
END:VEVENT`);
    }

    return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Pomodoro Study App//Auto Scheduler//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
${events.join('\n')}
END:VCALENDAR`;
  }

  private static parseDateTime(date: Date, time: string): Date {
    const [hours, minutes] = time.split(':').map(Number);
    const result = new Date(date);
    result.setHours(hours, minutes, 0, 0);
    return result;
  }

  // Integrate auto-schedule with manual schedule
  static mergeWithManualSchedule(autoSchedule: WeeklySchedule, manualSessions: any[]): WeeklySchedule {
    // This would merge auto-generated sessions with user's manual schedule
    // For now, just return auto schedule
    return autoSchedule;
  }
}
